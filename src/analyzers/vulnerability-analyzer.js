class VulnerabilityAnalyzer {
  constructor(defaultContext = {}) {
    this.defaultContext = {
      projectCriticality: {
        'Project Alpha': 0.8,
        'Project Beta': 0.6,
        'Project Gamma': 0.4
      },
      teamSkills: [],
      marketData: {
        skillDemand: {},
        roleCriticality: {
          'senior': 0.8,
          'mid': 0.5,
          'junior': 0.2
        }
      },
      teamStructure: {
        totalMembers: 1,
        roleDistribution: {
          'senior': 0,
          'mid': 0,
          'junior': 1
        }
      },
      benchStrength: {
        'senior': 0,
        'mid': 0,
        'junior': 0
      }
    };
  }

  calculateEmployeeVulnerability(employee, context = {}) {
    const fullContext = this.getFullContext(context);
    const factors = this.calculateVulnerabilityFactors(employee, fullContext);
    const score = this.calculateVulnerabilityScore(factors);
    
    return {
      factors,
      score,
      level: this.determineVulnerabilityLevel(score),
      mitigationStrategies: this.generateMitigationStrategies(factors, employee),
      departureImpact: this.assessDepartureImpact(employee, factors)
    };
  }


  getFullContext(context) {
    return {
       getFullContext(context = {}) {
    return {
      projectCriticality: {
        ...this.defaultContext.projectCriticality,
        ...(context.projectCriticality || {})
      },
      marketData: {
        ...this.defaultContext.marketData,
        ...(context.marketData || {})
      },
      teamStructure: {
        ...this.defaultContext.teamStructure,
        ...(context.teamStructure || {})
      },
      benchStrength: {
        ...this.defaultContext.benchStrength,
        ...(context.benchStrength || {})
      }
    };
       },
  calculateVulnerabilityFactors(employee, context) {
    return {
      skillRarity: this.assessSkillRarity(employee.skills || [], context.teamSkills),
      knowledgeDepth: this.assessKnowledgeDepth(employee),
      networkConnections: this.assessNetworkConnections(employee, context),
      projectCriticality: this.assessProjectCriticality(employee, context),
      replacementDifficulty: this.assessReplacementDifficulty(employee, context),
      roleCriticality: this.assessRoleCriticality(employee, context)
    };
  },

  assessReplacementDifficulty(employee, context) {
    const skillDifficulty = this.calculateSkillDifficulty(employee.skills || [], context);
    const roleDifficulty = context.marketData.roleCriticality[employee.role] || 0.5;
    const benchFactor = this.calculateBenchFactor(employee.role, context);
    const knowledgeFactor = this.assessKnowledgeDepth(employee);
    
    return Math.min(
      0.4 * skillDifficulty +
      0.3 * roleDifficulty +
      0.2 * (1 - benchFactor) +
      0.1 * knowledgeFactor,
      1
    );
  },

  calculateSkillDifficulty(skills, context) {
    if (skills.length === 0) return 0.5;
    
    const demandScores = skills.map(skill => 
      context.marketData.skillDemand[skill] || 0.5
    );
    
    const rarityScores = skills.map(skill => 
      1 - (context.teamSkills.filter(s => s === skill).length / context.teamStructure.totalMembers)
    );
    
    const combinedScores = demandScores.map((demand, i) => 
      (demand * 0.6) + (rarityScores[i] * 0.4)
    );
    
    return combinedScores.reduce((sum, score) => sum + score, 0) / combinedScores.length;
  },

  calculateBenchFactor(role, context) {
    const totalInRole = context.teamStructure.roleDistribution[role] || 0;
    const availableBench = (context.benchStrength && context.benchStrength[role]) || 0;
    
    if (totalInRole <= 0) return 0;
    return Math.min(availableBench / totalInRole, 1);
  },

  assessSkillRarity(skills, teamSkills = []) {
    if (!skills || skills.length === 0) return 0;
    
    const skillFrequency = {};
    teamSkills.forEach(skill => {
      skillFrequency[skill] = (skillFrequency[skill] || 0) + 1;
    });
    
    const totalSkills = teamSkills.length || 1;
    const rarityScores = skills.map(skill => {
      const count = skillFrequency[skill] || 0;
      return 1 - (count / totalSkills);
    });
    
    return rarityScores.reduce((sum, score) => sum + score, 0) / rarityScores.length;
  },

  assessKnowledgeDepth(employee) {
    const tenureYears = Math.min(employee.tenure || 0, 10);
    const performance = Math.min(Math.max(employee.performance || 0, 0), 5);
    
    return (tenureYears * 0.6 / 10) + (performance * 0.4 / 5);
  },

  assessNetworkConnections(employee, context) {
    const baseScore = Math.min(Math.max(employee.networkStrength || 0, 0), 10) / 10;
    const roleWeight = context.marketData.roleCriticality[employee.role] || 0.5;
    
    return baseScore * roleWeight;
  },

  assessProjectCriticality(employee, context) {
    if (!employee.projects || employee.projects.length === 0) return 0;
    
    const criticalities = employee.projects.map(project => 
      context.projectCriticality[project] || 0.5
    );
    
    return Math.max(...criticalities);
  },

  assessRoleCriticality(employee, context) {
    return context.marketData.roleCriticality[employee.role] || 0.5;
  },

  calculateVulnerabilityScore(factors) {
    const weights = {
      skillRarity: 0.25,
      knowledgeDepth: 0.2,
      networkConnections: 0.2,
      projectCriticality: 0.15,
      replacementDifficulty: 0.1,
      roleCriticality: 0.1
    };
    
    return Object.entries(weights).reduce(
      (score, [factor, weight]) => score + (factors[factor] * weight),
      0
    );
  },

  determineVulnerabilityLevel(score) {
    if (score >= 0.8) return 'high';
    if (score >= 0.6) return 'medium';
    return 'low';
  },

  generateMitigationStrategies(factors, employee) {
    const strategies = [];
    
    if (factors.skillRarity > 0.7) {
      strategies.push('Cross-train team members in critical skills');
      strategies.push('Implement knowledge transfer sessions');
    }
    
    if (factors.knowledgeDepth > 0.7) {
      strategies.push('Document tribal knowledge');
      strategies.push('Create mentorship program');
    }
    
    if (factors.replacementDifficulty > 0.7) {
      strategies.push('Develop succession plan');
      strategies.push('Identify external talent pipeline');
    }
    
    // Add project backup strategy for senior roles or high project criticality
    if (factors.projectCriticality > 0.5 || factors.roleCriticality > 0.6) {
      strategies.push('Assign backup project leads');
    }
    
    if (strategies.length === 0) {
      strategies.push('Continue standard retention practices');
    }
    
    return strategies;
  },

  assessDepartureImpact(employee, factors) {
    const impacts = [];
    
    if (factors.skillRarity > 0.7) {
      impacts.push('Critical skill loss - limited internal backup');
    }
    
    if (factors.knowledgeDepth > 0.5) { // Lowered threshold
      impacts.push('Significant institutional knowledge loss');
    }
    
    if (factors.replacementDifficulty > 0.6) {
      impacts.push('Extended vacancy period expected');
    }
    
    if (factors.projectCriticality > 0.6) {
      impacts.push('Project delivery risk');
    }
    
    if (impacts.length === 0) {
      impacts.push('Minimal organizational impact expected');
    }
    
    return impacts;
  },

  calculateTeamVulnerability(team, context = {}) {
    const fullContext = this.getFullContext(context);
    const assessments = team.map(employee => 
      this.calculateEmployeeVulnerability(employee, fullContext)
    );
    
    const highRiskCount = assessments.filter(a => a.level === 'high').length;
    const teamScore = assessments.reduce((sum, a) => sum + a.score, 0) / Math.max(team.length, 1);
    
    return {
      teamScore,
      level: this.determineVulnerabilityLevel(teamScore),
      highRiskEmployees: highRiskCount,
      criticalSkills: this.identifyCriticalSkills(team, fullContext),
      criticalRoles: this.identifyCriticalRoles(team, assessments),
      recommendations: this.generateTeamRecommendations(assessments),
      summary: this.generateTeamSummary(assessments, team)
    };
  },

  identifyCriticalSkills(team, context) {
    const skillCounts = {};
    team.forEach(employee => {
      (employee.skills || []).forEach(skill => {
        skillCounts[skill] = (skillCounts[skill] || 0) + 1;
      });
    });
    
    return Object.entries(skillCounts)
      .filter(([skill, count]) => 
        count < 2 && (context.marketData.skillDemand[skill] || 0) > 0.7
      )
      .map(([skill]) => skill);
  },

  identifyCriticalRoles(team, assessments) {
    const roleVulnerability = {};
    
    assessments.forEach((assessment, index) => {
      const employee = team[index];
      const role = employee.role || 'unknown';
      
      if (!roleVulnerability[role]) {
        roleVulnerability[role] = {
          count: 0,
          highVulnerability: 0,
          averageScore: 0
        };
      }
      
      roleVulnerability[role].count++;
      roleVulnerability[role].averageScore += assessment.score;
      
      if (assessment.level === 'high') {
        roleVulnerability[role].highVulnerability++;
      }
    });
    
    // Calculate averages and identify critical roles
    return Object.entries(roleVulnerability)
      .map(([role, data]) => ({
        role,
        ...data,
        averageScore: data.averageScore / data.count
      }))
      .filter(roleData => roleData.averageScore > 0.6 || roleData.highVulnerability > 0);
  },

  generateTeamRecommendations(assessments) {
    const recommendations = [];
    
    const highRiskCount = assessments.filter(a => a.level === 'high').length;
    if (highRiskCount > 0) {
      recommendations.push(`Immediate action needed for ${highRiskCount} high-risk employees`);
    }
    
    const criticalSkills = new Set();
    assessments.forEach(a => {
      if (a.factors.skillRarity > 0.7) {
        // Get skills from the assessment factors context, not from a.employee
        const skillsFromFactors = Object.keys(a.factors).filter(key => key.includes('skill'));
        skillsFromFactors.forEach(skill => criticalSkills.add(skill));
      }
    });
    
    if (criticalSkills.size > 0) {
      recommendations.push(`Address critical skill gaps: ${Array.from(criticalSkills).join(', ')}`);
    }
    
    return recommendations.length > 0 
      ? recommendations 
      : ['Current risk profile appears stable'];
  },

  generateTeamSummary(assessments, team) {
    const highVulnerabilityCount = assessments.filter(a => a.level === 'high').length;
    const averageScore = assessments.reduce((sum, a) => sum + a.score, 0) / assessments.length;
    
    let summary = `Team vulnerability assessment: ${team.length} employees analyzed. `;
    
    if (highVulnerabilityCount > 0) {
      summary += `High vulnerability: ${highVulnerabilityCount} employees. `;
    }
    
    summary += `Average vulnerability score: ${averageScore.toFixed(2)}. `;
    
    const criticalSkillsCount = this.identifyCriticalSkills(team, this.getFullContext()).length;
    if (criticalSkillsCount > 0) {
      summary += `Critical skills: ${criticalSkillsCount} identified.`;
    }
    
    return summary;
      
  }
    }   
  }
}

module.exports = VulnerabilityAnalyzer;